exit
array.max_by {|piece| piece.max_value_of_possible_captures }.pos
array.max_by {|piece| piece.max_value_of_possible_captures }.class
array.max_by {|piece| piece.max_value_of_possible_captures }
array.max_by {|piece| piece.max_value_of_possible_capturse }
array.max_by {|piece| piece.max_value_of_possible_capture }
exit
array.max_by {|piece| piece.max_value_of_possible_captures }
exit
array.first
array.first.class
array.first
array.count
array
exit
possible_starts.count
possible_starts
exit
self.value
exit
self.class.to_s.to_sym
self.class.to_s
self.class.to_sym
self.class
exit
self.class.class
self.class
self.calss
PIECE_VALUE[Pawn]
PIECE_VALUE[:Pawn]
PIECE_VALUE
PIECE_VLUE
Piece_value
Piece_valu
PIECE_VALUE[self.class]
self.colour
self.class
@value
self.class
self
self.value
exit
self.class
exit
board.black_pieces.count
board.black_pieces
black_pieces
possible_starts.count
c
possible_starts.first.class
possible_starts.first
possible_starts.count
possible_starts
possible_strts
c
exit
self.class
self
exit
c
exit
self.class
self
c
board.black_pieces.each {|piece| p piece.class}.count
c
board.black_pieces.each {|piece| p piece.class}.count
boar
c
board.black_pieces.each {|piece| p piece.class}.count
c
board.black_pieces.each {|piece| p piece.class}.count
board.black_pieces.each {|piece| puts piece.class}
board.black_pieces.each {|piece| p piece.class}
board.black_pieces.count
board.white_pieces.count
c
board.white_pieces.count
c
board.white_pieces.count
board.black_pieces.count
n
c
board.black_pieces.count
board.black_pieces
exit
board.white_pieces
board.white_pieces.count
board.black_pieces.count
board.black_pieces.last.class
board.black_pieces.last.pos
board.black_pieces.last.can_move?
board.black_pieces.first.can_move?
board.black_pieces.first.pos.can_move?
board.black_pieces.first.pos
board.black_pieces.first
board.black_pieces.firs
board.black_pieces.select {|piece| piece.can_move? }
board.black_pieces.select {|piece| true }
board.black_pieces.select {|piece| piece.class == Pawn }
board.black_pieces
board.selected_piece
@board.pieces_that_can_move(@colour)
@board.pieces_that_can_move(@colour
@colour
board
board.pieces_that_can_move(@colour)
board.pieces_that_can_move(@colour).count
possible_starts.empty?
possible_starts
@selected_piece
exit
eix
array.select {|pos| board[*pos].class != EmptySpace }.samplei
array.select {|pos| board[*pos].class != EmptySpace }.sample
array.select {|pos| board[*pos].class != EmptySpace }
array.each {|pos| p board[*pos].class }
array
a
board.pieces_that_can_move(@colour).each { |piece| array.concat(piece.actual_possible_moves) }
board.pieces_that_can_move(@colour).each do |piece|
array = []
exit
board.pieces_that_can_move(@colour).
board.pieces_that_can_move(@colour).count
board.pieces_that_can_move(@colour)
exit
c
self
ls
c
exit
char
n
pos
board.cursor_pos
s
n
board.cursor_pos
@start
@destination
board.selected_piece.pos
board.selected_piece
board.cursor_pos
@cursor_pos
@destination
s
n
c
n
c
n
c
n
s
n
board.cursor_pos == @destination
board.selected_piece.nil?
board.cursor_pos
@destination
s
n
board.cursor_pos[0] < pos [0]
board.cursor_pos[0]
s
@destination
n
@destination
board.cursor_pos
n
board.selected_piece.nil?
board.selected_piece
n
@destination
@destinaion
n
@destination
@selected_piece.class
@selected_piece.actual_possible_moves
@selected_piece.pos
@selected_piece
@destination
@start
n
s
n
c
n
s
board.selected_piece
@destination
@selected_piece.actual_possible_moves
@selected_piece.pos.actual_possible_moves
@selected_piece.pos
@board.cursor_pos
@destination
c
n
@destination
@start
n
selected_piece.class
selected_piece.pos
selected_piece
board.selected_piece.pos
board.selected_piece
board.cursor_pos
@destination
@start
c
@selected_piece.pos
@selected_piece
c
n
s
@selected_piece.pos
@selected_piece
c
@selected_piece
exit
@start
selected_piece
exit
@white_pieces.select {|piece| piece.can_move?}.sample.pos
@white_pieces.select {|piece| piece.can_move?}.sample
@white_pieces.select {|piece| piece.can_move?}.count.sample
@white_pieces.select {|piece| piece.can_move?}.count
@white_pieces.select {|piece| piece.can_move?}
white_pieces.last.can_move?
white_pieces.first.can_move?
white_pieces.first.class
white_pieces.first
white_pieces.count
white_pieces.last.class
white_pieces.first.class
self[0,0].class
self[0,0]
self.class
self
white_pieces
exit
white_pieces
exit
@white_pieces
white_pieces
exit
self
exit
selected_piece
current_player.colour
current_player
c
n
current_player
player1.colour
player1
